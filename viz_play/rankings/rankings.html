<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">

<link rel="stylesheet" href="http://fletcherhaz.github.io/sorel/css/slick.grid.css" type="text/css"/>
<link rel="stylesheet" href="http://fletcherhaz.github.io/sorel/css/jquery-ui-1.8.16.custom.css" type="text/css"/>
<link rel="stylesheet" href="http://fletcherhaz.github.io/sorel/css/slick-default-theme.css" type="text/css"/>

<link rel="stylesheet" type="text/css" href="http://fletcherhaz.github.io/sorel/css/main.css">
<link rel="stylesheet" type="text/css" href="http://fletcherhaz.github.io/sorel/css/rankings.css">

<!-- Need to use JQuery 1.7 for SlickGrid -->
<script src="http://fletcherhaz.github.io/sorel/lib/jquery-1.7.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>

<script src="http://fletcherhaz.github.io/sorel/lib/jquery.event.drag-2.0.min.js"></script>
<script src="http://fletcherhaz.github.io/sorel/lib/slick.core.js"></script>
<script src="http://fletcherhaz.github.io/sorel/lib/slick.grid.js"></script>

<title>Category Rankings</title>

</head>

<body>

<div class="main">

    <div class="settings">

        <div class="setting">
            <span class="setting-name">Ranks or Values for Graph</span>
            <div class="setting-value">
                <input type="radio" name="graphtype" id="ranks" value="ranks" onchange="changeData()" checked>Ranks<br>
                <input type="radio" name="graphtype" id="values" value="values" onchange="changeData()">Values<br>
            </div>
        </div>

        <div class="setting">
            <span class="setting-name">Detrend by # words in category</span>
            <div class="setting-value">
                <input type="radio" name="start" id="detrend" value="detrend" onchange="changeData()">Yes<br>
                <input type="radio" name="start" id="nodetrend" value="nodetrend" onchange="changeData()" checked>No<br>
            </div>
        </div>

        <div class="setting">
            <span class="setting-name">Notes:</span>
            <div class="setting-value">
                Single click on a category in the table to add or remove it to the graph.
            </div>
        </div>

        <div class="setting">
            <span class="setting-name"></span>
            <div class="setting-value">
            </div>
        </div>

    </div>

    <div class="rankings">

        <div id="graph">
        </div>

        <div id="grid">
        </div>

    </div>

</div>

</body>

<script>

var dsv = d3.dsv('#', 'text/plain');
var graphData, shownData;
var ranks = true;

var columns = [
    {id: "1000", name: "1000", field: "1000", width: 150, formatter: formatter},
    {id: "1100", name: "1100", field: "1100", width: 150, formatter: formatter},
    {id: "1200", name: "1200", field: "1200", width: 150, formatter: formatter},
    {id: "1300", name: "1300", field: "1300", width: 150, formatter: formatter},
    {id: "1400", name: "1400", field: "1400", width: 150, formatter: formatter},
    {id: "1500", name: "1500", field: "1500", width: 150, formatter: formatter},
    {id: "1600", name: "1600", field: "1600", width: 150, formatter: formatter},
    {id: "1700", name: "1700", field: "1700", width: 150, formatter: formatter},
    {id: "1800", name: "1800", field: "1800", width: 150, formatter: formatter},
    {id: "1900", name: "1900", field: "1900", width: 150, formatter: formatter},
    {id: "2000", name: "2000", field: "2000", width: 150, formatter: formatter}
];

var options = {
    enableCellNavigation: true,
    enableColumnReorder: false,
    rowHeight: 23,
    cellFlashingCssClass: "flasher"
};

var div = d3.select("body").append("div")
    .attr("class", "tooltip")             
    .style("opacity", 0);

var colors = d3.scale.category10();

var grid;
var svgGroup, line, x;

var shownSeries = {};
function formatter(row, cell, value, columnDef, dataContext) {
    if(shownSeries[row] && shownSeries[row][cell])
        return '<div style="padding:0;margin:0;background-color:' + shownSeries[row][cell] + ';color:white;">&nbsp;' + value + '</div>';
    else
        return '<div>&nbsp;' + value + '</div>';
}

// How many years are there
var years = [];
var width = 800;
var height = 300;
var svg, margin;

$(function()
{
    // Change the divs to a fixed width now that they're rendered
    width = $('.rankings').width() - 230;
    if(width < 800)
        width = 800;
    if(width > 1400)
        width = 1400;
    height = $('.rankings').height() - 10;
    if(height < 500)
        height = 500;
    $('.rankings').css('width', width + "px");
    $('.rankings').css('height', height + "px");
    $('.rankings').css('top', '0');
    $('.rankings').css('position', 'relative');
    $('#grid').css('height', Math.round(height/2));

    margin = {top: 20, right: 30, bottom: 30, left: 100};
    width = width - margin.left - margin.right;
    height = Math.round(height/2) - margin.top - margin.bottom;

    svg = d3.select("#graph").append("svg")
        .attr("id", "graphsvg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom);

    changeData();
});

function changeData()
{
    var detrend = '';
    if(document.getElementById('detrend').checked)
        detrend = '_detrended';

    if(document.getElementById('ranks').checked)
        ranks = true;
    else
        ranks = false;

    // Figure out what years to show
    years = [];
    for(var i=1000; i<2001; i+=100) years.push(i);

    // Load up the data and show it
    loadGrid(detrend);
}

function loadGrid(detrend)
{
    d3.json('grid' + detrend + '.json', function(error, slick_data)
    {
        grid = new Slick.Grid("#grid", slick_data, columns, options);

        grid.onClick.subscribe(function(e,args) {
            var cell = grid.getCellFromEvent(e);
            changeSeries(cell);
        });

        // highlight row in chart
        grid.onMouseEnter.subscribe(function(e,args) {
            var cell = grid.getCellFromEvent(e);
            svgGroup.selectAll(".category")
                .style("stroke-width", 
                    function(d)
                    {
                        if(d.ranks[cell.cell].value == cell.row)
                            return 4;
                        else
                            return 2;
                    }
                );
        });
        grid.onMouseLeave.subscribe(function(e,args) {
            var cell = grid.getCellFromEvent(e);
            svgGroup.selectAll(".category")
                .style("stroke-width", "2");
        });
        loadGraph(detrend);
    });
}

function loadGraph(detrend)
{
    svg.selectAll("*").remove();

    svgGroup = svg.append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    d3.json('graph' + detrend + '.json', function(error, data) {
        if (error) throw error;

        var lastYear = years.length-1;
        data.sort(function(a, b) {
            if(ranks)
                return d3.ascending(a.ranks[lastYear].value, b.ranks[lastYear].value);
            else
                return d3.descending(a.values[lastYear].value, b.values[lastYear].value);
        });

        data.forEach(function(d, i) {
            d.color = colors(i);
        });

        graphData = data.slice();
        
        shownData = data.splice(0, 10);

        updateGridColors();

        // x-axis
        x = d3.scale.linear()
            .range([0, width])
            .domain([years[0], years[lastYear]]);
        var xAxis = d3.svg.axis()
            .scale(x)
            .orient("bottom")
            .tickPadding(4)
            .tickFormat(d3.format("d"));
        var axis = svgGroup.append("g")
            .attr("id", "xAxis")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis);
        axis.selectAll("line, path")
            .style("fill", "none")
            .style("stroke", "#000")
            .style("shape-rendering", "crispEdges");
        // Add the text label for the x axis
        axis.append("text")
            .attr("id", "xlabel")
            .attr("transform", "translate(" + (width / 2) + " ," + (svg.select("#xAxis").node().getBBox().height+5) + ")")
            .style("text-anchor", "middle")
            .text("Year");

        // y-axis
        var y = d3.scale.linear();
            
        if(ranks)
            y.range([height, 0]).domain([
                d3.max(shownData, function(c) { return d3.max(c.ranks, function(v) { return v.value; }); }),
                d3.min(shownData, function(c) { return d3.min(c.ranks, function(v) { return v.value; }); })
            ]);
        else
            y.range([height, 0]).domain([
                d3.min(shownData, function(c) { return d3.min(c.values, function(v) { return v.value; }); }),
                d3.max(shownData, function(c) { return d3.max(c.values, function(v) { return v.value; }); })
            ]);
        var yAxis = d3.svg.axis()
            .scale(y)
            .orient("left");
        var axis = svgGroup.append("g")
            .attr("id", "yAxis")
            .call(yAxis);
        axis.selectAll("line, path")
            .style("fill", "none")
            .style("stroke", "#000")
            .style("shape-rendering", "crispEdges");
        // Add a text label for the y axis
        var label = axis.append("text")
            .attr("id", "ylabel")
            .attr("transform", "translate(-60," + (height/2) + ")rotate(-90)")
            .style("text-anchor", "middle");
        if(ranks)
            label.text('Rank of tag')
        else
            label.text('# articles with tag');

        // Create the line drawer
        line = d3.svg.line()
            .interpolate("linear")
            .x(function(d) { return x(d.date); })
            .y(function(d) { return y(d.value); });

        // Draw the lines
        var categories = svgGroup.selectAll(".category")
            .data(shownData)
          .enter().append("path")
            .attr("class", "category")
            .attr("d", function(d) { if(ranks) return line(d.ranks); else return line(d.values);})
            .style("stroke", function(d, i) { return d.color })
            .style("fill", "none")
            .style("stroke-width", function(d, i) { return 2; });

        // Add mouse interaction with the lines
        addMouse(categories);
    });

}

function changeSeries(cell)
{
    var row = cell.row;
    var cell = cell.cell;

    // Get the index of the series in the graphData array
    var series_index;
    graphData.every(function(d, i) {
        if(d.ranks[cell].value == row)
        {
            series_index = i;
            return false;
        }
        return true;
    });

    // If we are adding the series
    if(!shownSeries[row] || !shownSeries[row][cell])
    {
        // Add it
        shownData.push(graphData[series_index]);
    }
    else
    {
        // Remove it
        shownData = shownData.filter(function(d) {
            return d.name !== graphData[series_index].name;
        });
    }

    // Update the coloring
    updateGridColors();

    var y = d3.scale.linear()
        .range([height, 0]);
    if(ranks)
        y.domain([
            d3.max(shownData, function(c) { return d3.max(c.ranks, function(v) { return v.value; }); }),
            d3.min(shownData, function(c) { return d3.min(c.ranks, function(v) { return v.value; }); })
        ]);
    else
        y.domain([
            d3.max(shownData, function(c) { return d3.max(c.values, function(v) { return v.value; }); }),
            d3.min(shownData, function(c) { return d3.min(c.values, function(v) { return v.value; }); })
        ]);

    var yAxis = d3.svg.axis()
        .scale(y)
        .orient("left");
    // Update the y-axis
    svgGroup.selectAll("#yAxis").remove();
    var axis = svgGroup.append("g")
        .attr("id", "yAxis")
        .call(yAxis);
    axis.selectAll("line, path")
        .style("fill", "none")
        .style("stroke", "#000")
        .style("shape-rendering", "crispEdges");

     // Add a text label for the y axis
    label = axis.append("text")
        .attr("id", "ylabel")
        .attr("transform", "translate(-60," + (height/2) + ")rotate(-90)")
        .style("text-anchor", "middle");
    if(ranks)
        label.text('Rank of tag')
    else
        label.text('# articles with tag');

    // Create the line drawer
    line = d3.svg.line()
        .interpolate("linear")
        .x(function(d) { return x(d.date); })
        .y(function(d) { return y(d.value); });

    // Update the graph data
    var categories = svgGroup.selectAll(".category").data(shownData);

    // Add the new lines
    categories.enter().append("path")
        .attr("class", "category")
        .attr("d", function(d) { if(ranks) return line(d.ranks); else return line(d.values); })
        .attr("id", function(d, i) { return d.name.slice(4);})
        .style("stroke-width", "0");

    categories.exit()
        // Change the class so the selection below doesn't overwrite this
        // transition and removal
        .attr("class", "empty-link")
          // Fade out
        .transition().duration(500)
          .style("stroke-opacity", function(d) { return 0; })
          .remove();

    // Re-select the correct lines
    categories = svgGroup.selectAll(".category");

    // Transition in the new lines
    categories.transition().duration(500)
        .attr("d", function(d) { if(ranks) return line(d.ranks); else return line(d.values); })
        .style("stroke", function(d, i) { return d.color })
        .style("fill", "none")
        .style("stroke-width", function(d, i) { return 2; });

    // Add the mouse interaction
    addMouse(categories);
}

function updateGridColors()
{
    // First, we invalidate all the current rows so that anything that will
    // not be added back in get's wiped clean
    for(var key in shownSeries)
        grid.invalidateRow(key);
    // Then delete all the rows
    shownSeries = {};
    // Then add in all the rows we are coloring
    shownData.forEach(function(d) {
        d.ranks.forEach(function(r) {
            if(!shownSeries[r.value])
                shownSeries[r.value] = {};
            shownSeries[r.value][years.indexOf(r.date)] = d.color;
            grid.invalidateRow(r.value);
        });
    });
    grid.render();
}

function addMouse(categories)
{
    categories
        .on("mouseover", function(d, i) {
            //var this_year = d3.bisectRight(years, Math.round(x.invert(d3.mouse(this)[0])/100)*100)-1;
            var this_year = Math.round(x.invert(d3.mouse(this)[0])/100)*100;
            var year_index = d3.bisectRight(years, this_year)-1;
            var this_value = d.values[year_index].value;
            grid.scrollRowIntoView(d.ranks[year_index].value);
            grid.scrollCellIntoView(d.ranks[year_index].value, grid.getColumnIndex(this_year));
            grid.flashCell(d.ranks[year_index].value, grid.getColumnIndex(this_year), 100);
            // // Make this path bold
            d3.select(this).style("stroke-width", 4);
            // Transition the div to visible
            div.transition()
                .duration(200)
                .style("opacity", .9);
            div.html(d.name + ":" + this_value + "<br/>")
                .style("background-color", d.color)
                .style("left", (d3.event.pageX) + "px")
                .style("top", (d3.event.pageY - 28) + "px");
        })
        .on("mouseout", function(d) {
            d3.select(this).style("stroke-width", 2);
            div.transition()
                .duration(500)
                .style("opacity", 0);
        });
}


</script>

</html>
